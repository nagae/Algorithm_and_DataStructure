* 配列
下記のような顧客の名前, 年齢, 性別を管理したい.

| 名前  | 年齢 | 性別   |
|-------+------+--------|
| Alice |   23 | female |
| Bob   |   17 | male   |
| Cathy |   32 | female |
| David |   25 | male   |
| Ethan |   48 | male   |
| Flank |   27 | male   |
| Gina  |   42 | female |

* ナイーブな方法
人数分の名前・年齢・性別を格納するための変数を用意することもできるが, 
顧客が増減するたびに膨大なソース・コードの修正が必要であり, とても現実的ではない.

- [[file:naive_array.c][Cによる実装]]
- [[file:naive_array.cpp][C++による実装]]

** ソース・コード解説
- 名前, 年齢, 性別を整形表示するのに関数 =show_client= を定義している.

** C vs C++
- Cの標準入出力ライブラリは =<stdio.h>= で,
  標準出力への書き出しは =printf("%-10s %3d", name, age);= などとする.
- C++の標準入出力ライブラリは =<iostream>= で, その操作に =<iomanip>= を用いる.
  標準出力への書き出しは
  =cout << setw(10) << left << name << setw(3) << right << dec << age << endl;=
  などとする. 

  その際, =using namespace= を使ってデフォルトの名前空間を =std= にしている.
  そうしないと上記のコードが
  =std::cout << std::setw(10) << std::left << name << std::setw(3) << std::right << std::dec << age << std::endl;=
  とごちゃっとする.
- Cの文字列は =char= 型の *配列* として実装されており, その操作には =<string.h>= ライブラリにある
  下記のような関数を用いる.
  #+BEGIN_SRC c
    char name[10];			// 宣言
    strcpy(name, "Alice");		// 代入
    if ( strcmp(name, "Bob") == 0){	// 比較
      //
     }
    printf( "%d", strlen(name) );	// 文字列の長さ
  #+END_SRC

  文字列を関数に渡す時は, 以下のように *ポインタ* を使う.
  #+BEGIN_SRC c
    // 文字列 str を表示
    void func(char* str){		// 受け取った str が文字型配列(ポインタ)であることを明示するのに * をつける
      printf("%s", str);
    }

    // メイン関数
    int main(void){
      char str[10] = "hoge";
      func(str);			// str は先頭の要素のアドレスであることに注意
    }
  #+END_SRC
- C++ には文字列を扱う =<string>= ライブラリ中に =string= 型が用意されており,
  以下のように直感的に代入や比較が行なえる.
  #+BEGIN_SRC C++
      string name;			// 宣言
      name = "Alice";		// 代入
      if (name == "Bob"){		// 比較
        // 
      }
      cout << name.length();	// 文字列の長さ
  #+END_SRC

  =string= 型を関数に渡す時は, 以下のように *参照* を使う.
  #+BEGIN_SRC C++
    // 文字列 str を表示
    void func(string& str){		// 引数に & をつけることで, str のアドレスが渡される
      cout << str;
    }

    // メイン関数
    int main(void){
      string str = "hoge";
      func(str);			// 呼び出す側からは渡されるのが変数の実体なのかアドレスなのかは見えない
    }
  #+END_SRC

  

* 配列を使う
こうした多くのデータを取り扱うには *配列* を用いるのが一般的. 
名前・年齢・性別のそれぞれを配列で格納する方法を示そう.

- [[file:array_with_initialize.c][Cによる実装]]
- [[file:array_with_initialize.cpp][C++による実装]]

** C vs C++
- C の静的配列は =int age[10];= のように配列宣言時にサイズを記載する必要がある. しかし, 配列のサイズを =10= から =100= へと
  変えた時に, ソース・コードの該当する箇所(例えば, =for ( int ID = 0; ID < 10; ID ++){= など)を, *全て* 書き換えなければならない.

  この問題を解消するために, 一般的にはマクロを使う. 具体的には, ヘッダ部分に =#define mem_size 10= とマクロを定義し,
  =int age[mem_size];= や =for ( int ID = 0; ID < mem_size; ID ++){= などと記述する. 
  これなら, 与える配列のサイズが変わってもマクロの宣言部分だけを変更すればよい.
- C++ の静的配列のサイズは *整数型(=const int=)の定数* を用いて指定できる. 例えば, =const int mem_size = 5;= としておけば,
  =int age[mem_size];= として指定できる.
- C/C++ では, 配列の *宣言時* に ={}= を使うことで *初期化* が可能. 例えば, =int age[5] = {23, 17, 32};= とすれば,
  =age= の中身は ={23, 17, 32, 0, 0}= となる. これが可能なのは *初期化* の場合に限られる. =int age[5];= と宣言した「後」に
  =age[5] = {23, 17, 32};= といった *代入* はできない点に注意.

* ファイルから入力する
データをソース・コードに直接記述するのではなく, 
以下のように顧客データをスペースで区切った =data.txt= というファイルから読み込めるようにしたい.
#+BEGIN_SRC txt
Alice    23  female
Bob      17  male  
Cathy    32  female
David    25  male  
Ethan    48  male  
Flank    27  male  
Gina     42  female
#+END_SRC

- [[file:array_from_file.c][Cによる実装]]
- [[file:array_from_file.cpp][C++による実装]]

** ソース・コード解説
- 入力ファイルストリームがファイル終端を指すか, 取り込んだ顧客データ数が =mem_size= に達するまで順にデータを読込んでいる.
  最後の行を読込む時に改行コードだけ残ることがあるので,
  名前, 年齢, 性別の3つが読み込めなければ, その顧客データを無効(名前を空文字列)にしている.

** C vs C++
- C のファイル入力には =<stdio.h>= に含まれる =FILE= 型のファイルストリームや =fopen=, =scanf=, =fcloe= などの関数を使う:
  #+BEGIN_SRC C
    FILE ifs;			// ファイルストリームを宣言
    ifs = fopen("data.txt", "r");	// 入力モードでファイルストリームを開く
    fscanf(ifs, "%s%d", name, &age); // ファイルから文字型配列 name と 整数型変数 age に読込む
    fclose(ifs);			 // ファイルストリームを閉じる
  #+END_SRC
- C++ ではファイル入出力ライブラリ =fstream= に含まれる =ifstream= 型のファイルストリームや =>>= 演算子を使う:
  #+BEGIN_SRC C++
    ifstream ifs("data.txt");      // 入力ファイルストリームを宣言して開く
    ifs >> name >> age;	       // name と age に読込む
    ifs.close();		       // 入力ファイルストリームを閉じる
  #+END_SRC


* 構造体/クラスを使う
上述の方法では, 各顧客についての情報が変化する(eg. 血液型を追加する)とソース・コード全体を変更しなければならない. そこで, 各顧客の情報を格納する =Client= という *構造体* や *クラス* を用いると汎用性が高まる.

- [[file:struct_array.c][Cによる実装]]
- [[file:class_array.cpp][C++による実装]]

** C vs C++
- C の構造体の *メンバ変数* (=name, age, is_male=)は, 基本的にどの関数からでも直接アクセスできる. 
  クラス固有の *メンバ関数* や, 受け取ったクラスによって処理が変わるような *関数の overload* も存在しない.

  大きなメモリを使う構造体は, 実体ではなく, それを指す番地を渡して *ポインタ* として受け取るのが一般的. 
  #+BEGIN_SRC C
    void func(Client* client){	// 受け取った client が Client型のポインタであることを明示
      printf("%s %d",
  	   client->name, client->age); // client が指す実体のメンバには -> 演算子でアクセスできる.
    }

    int main(void){
      Client client;		// Client型の変数を定義
      func( &client);		// 関数 func に client を指すアドレスを渡すことを指示
    }
  #+END_SRC

- C++ のクラスのメンバ変数(=name, age, is_male=)は, デフォルトでは *プライベート* となり, 他の関数やオブジェクトから直接アクセスできない.
  これを回避して C の構造体とコードを近づけるため, メンバ変数を =public:= の後に宣言する. これにより, *構造体* のメンバ変数と同様に直接アクセスできる.
  
  クラスを定義した後, *ストリーム出力演算子* =<<= を overload することで, 
  クライアント情報を出力するのに =cout << client[ID] << endl= といった簡潔かつ自由度の高い記述を可能にしている.
  同様に,  *ストリーム入力演算子* =>>= を overload することで, 
  クライアント情報を読込むのに =ifs >> client[ID]= といった記述を可能にしている.

  C++ では大きなメモリを使うオブジェクトの番地渡しを直感的に記述するのに *参照* 渡しが利用される.
  #+BEGIN_SRC C++
    void func(const Client& client){ // 引数に & をつけることで, client のアドレスが渡される.
                                     // 関数内で client の中身をうっかり変えてしまうことのないように
                                     // 定数を表す const をつける. 
      cout << client.name << client.age; // 関数内では client は実体として扱える
    }

    int main(void){
      Client client; // Client型の変数を定義
      func(client);	 // 呼び出す側からは渡されるのが変数の実体なのかアドレスなのかは見えない
    }
  #+END_SRC


