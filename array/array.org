* 配列
下記のような顧客の名前, 年齢, 性別を管理したい.

| 名前  | 年齢 | 性別   |
|-------+------+--------|
| Alice |   23 | female |
| Bob   |   17 | male   |
| Cathy |   32 | female |
| David |   25 | male   |
| Ethan |   48 | male   |
| Flank |   27 | male   |
| Gina  |   42 | female |

** ナイーブな方法
以下のように人数分の名前・年齢・性別を格納するための変数を用意することもできるが, 
顧客が増減するたびに膨大なソース・コードの修正が必要であり, とても現実的ではない.

- [[file:naive_array.c][Cによる実装]]
- [[file:naive_array.cpp][C++による実装]]

*** C vs C++
- Cの標準入出力ライブラリは =<stdio.h>= で, 
  標準出力への書き出しは =printf("%-10s %3d", name, age);= などとする.
- C++の標準入出力ライブラリは =<iostream>= および =<iomanip>= で,
  標準出力での書き出しは
  =cout << setw(10) << left << name << setw(3) << right << dec << age << endl;=
  などとする.

  その際, =using namespace= を使ってデフォルトの名前空間を =std= にしている.
  そうしないと上記のコードが
  =std::cout << std::setw(10) << std::left << name << std::setw(3) << std::right << std::dec << age << std::endl;=
  とごちゃっとする.

** 配列を使う
こうした多くのデータを取り扱うには *配列* を用いるのが一般的. 
以下では, 名前・年齢・性別のそれぞれを配列で格納している.

- [[file:array_with_initialize.c][Cによる実装]]
- [[file:array_with_initialize.cpp][C++による実装]]

*** C vs C++

- 配列のサイズは =const int= (整数定数)型 =mem_size= で与えている.
- ={}= を使うことで, 配列の宣言と同時に初期化を行なっている.
- 関数 =show_client= にはこれらの配列の *ポインタ* (変数名に =*= をつけている)を渡している.

** ファイルから入力する
データをソース・コードに直接記述するのではなく, 
以下のように顧客データをスペースで区切った =data.txt= というファイルから読み込めるようにしたい.
#+BEGIN_SRC txt
Alice    23  female
Bob      17  male  
Cathy    32  female
David    25  male  
Ethan    48  male  
Flank    27  male  
Gina     42  female
#+END_SRC

- [[file:array_from_file.c][Cによる実装]]
- [[file:array_from_file.cpp][C++による実装]]

*** C vs C++

- ファイル入出力ライブラリ =fstream= を使い, =fp = fopen("data.txt"); fscanf(fp, "%s %d", &name, &age);=
  などの代わりに =ifstream iof("data.txt"); iof >> name >> age;= とする.


** 構造体/クラスを使う
上述の方法では, 各顧客についての情報が変化する(eg. 血液型を追加する)とソース・コード全体を変更しなければならない. そこで, 各顧客の情報を格納する =Client= という *構造体* や *クラス* を用いると汎用性が高まる.

- [[file:struct_array.c][Cによる実装]]
- [[file:class_array.cpp][C++による実装]]

*** C vs C++
1. クラス・メンバ変数(=name, age, is_male=)を =public:= の後に宣言することで, *構造体* と同様に自由にアクセスできる.
2. クラスを定義した後, *ストリーム出力演算子* =<<= を overload することで, クライアント情報を出力するのに =cout << client[ID] << endl= といった簡潔かつ自由度の高い記述が可能.
3. 同様に *ストリーム入力演算子* =>>= を overload することで, クライアント情報を読込むのに =ifs >> client[ID]= といった簡潔かつ自由度の高い記述が可能．


