* 配列
下記のような顧客の名前, 年齢, 性別を管理したい.

| 名前  | 年齢 | 性別   |
|-------+------+--------|
| Alice |   23 | female |
| Bob   |   17 | male   |
| Cathy |   32 | female |
| David |   25 | male   |
| Ethan |   48 | male   |
| Flank |   27 | male   |
| Gina  |   42 | female |

* ナイーブな方法
人数分の名前・年齢・性別を格納するための変数を用意することもできるが, 
顧客が増減するたびに膨大なソース・コードの修正が必要であり, とても現実的ではない.

- [[file:naive_array.c][Cによる実装]]
- [[file:naive_array.cpp][C++による実装]]

** ソース・コード解説
- Cの標準入出力ライブラリは =<stdio.h>= で,
  標準出力への書き出しは =printf("%-10s %3d", name, age);= などとする.
- C++の標準入出力ライブラリは =<iostream>= で, その操作に =<iomanip>= を用いる.
  標準出力への書き出しは
  =cout << setw(10) << left << name << setw(3) << right << dec << age << endl;=
  などとする. 

  その際, =using namespace= を使ってデフォルトの名前空間を =std= にしている.
  そうしないと上記のコードが
  =std::cout << std::setw(10) << std::left << name << std::setw(3) << std::right << std::dec << age << std::endl;=
  とごちゃっとする.
- Cの文字列は =char= 型の *配列* として実装されており, その操作には =<string.h>= ライブラリにある
  下記のような関数を用いる.
  | 文字列の代入 | ~strcpy(name, "Alice")~  | ~name~ に "Alice" を代入                            |
  | 文字列の比較 | ~strcmp(name, "Bob")~   | ~name~ と "Bob" を比較し, 一致するなら 0 を返す     |
  | 文字列の長さ | ~strlen(name)~          | ~name~ の長さを求める                               |
#+TBLFM: 
- C++ には文字列を扱う =<string>= ライブラリ中に =string= 型が用意されており,
  | 文字列の代入 | =name = "Alice"=  | ~name~ に "Alice" を代入                        |
  | 文字列の比較 | src_C{name="Bob"} | ~name~ と "Bob" を比較し, 一致するなら 0 を返す |
  | 文字列の長さ | ~name.length()~   | ~name~ の長さを求める                           |
  

* 配列を使う
こうした多くのデータを取り扱うには *配列* を用いるのが一般的. 
名前・年齢・性別のそれぞれを配列で格納する方法を示そう.

- [[file:array_with_initialize.c][Cによる実装]]
- [[file:array_with_initialize.cpp][C++による実装]]

** ソース・コード解説
- C の静的配列は =int age[10];= のように配列宣言時にサイズを記載する必要がある. しかし, 配列のサイズを =10= から =100= へと
  変えた時に, ソース・コードの該当する箇所(例えば, =for ( int ID = 0; ID < 10; ID ++){= など)を, *全て* 書き換えなければならない.

  この問題を解消するために, 一般的にはマクロを使う. 具体的には, ヘッダ部分に =#define mem_size 10= とマクロを定義し,
  =int age[mem_size];= や =for ( int ID = 0; ID < mem_size; ID ++){= などと記述する. 
  これなら, 与える配列のサイズが変わってもマクロの宣言部分だけを変更すればよい.
- C++ の静的配列のサイズは *整数型(=const int=)の定数* を用いて指定できる. 例えば, =const int mem_size = 5;= としておけば,
  =int age[mem_size];= として指定できる.
- C/C++ では, 配列の *宣言時* に ={}= を使うことで *初期化* が可能. 例えば, =int age[5] = {23, 17, 32};= とすれば,
  =age= の中身は ={23, 17, 32, 0, 0}= となる. これが可能なのは *初期化* の場合に限られる. =int age[5];= と宣言した「後」に
  =age[5] = {23, 17, 32};= といった *代入* はできない点に注意.

* ファイルから入力する
データをソース・コードに直接記述するのではなく, 
以下のように顧客データをスペースで区切った =data.txt= というファイルから読み込めるようにしたい.
#+BEGIN_SRC txt
Alice    23  female
Bob      17  male  
Cathy    32  female
David    25  male  
Ethan    48  male  
Flank    27  male  
Gina     42  female
#+END_SRC

- [[file:array_from_file.c][Cによる実装]]
- [[file:array_from_file.cpp][C++による実装]]

** ソース・コード解説
- C

- ファイル入出力ライブラリ =fstream= を使い, =fp = fopen("data.txt"); fscanf(fp, "%s %d", &name, &age);=
  などの代わりに =ifstream iof("data.txt"); iof >> name >> age;= とする.


* 構造体/クラスを使う
上述の方法では, 各顧客についての情報が変化する(eg. 血液型を追加する)とソース・コード全体を変更しなければならない. そこで, 各顧客の情報を格納する =Client= という *構造体* や *クラス* を用いると汎用性が高まる.

- [[file:struct_array.c][Cによる実装]]
- [[file:class_array.cpp][C++による実装]]

** C vs C++
1. クラス・メンバ変数(=name, age, is_male=)を =public:= の後に宣言することで, *構造体* と同様に自由にアクセスできる.
2. クラスを定義した後, *ストリーム出力演算子* =<<= を overload することで, クライアント情報を出力するのに =cout << client[ID] << endl= といった簡潔かつ自由度の高い記述が可能.
3. 同様に *ストリーム入力演算子* =>>= を overload することで, クライアント情報を読込むのに =ifs >> client[ID]= といった簡潔かつ自由度の高い記述が可能．


